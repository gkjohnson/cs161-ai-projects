;;;Homework 1 - Garrett Johnson;;;;;;SUB-LIST;;;;returns a sub list of the list L, length LEN starting at position START;L: list from which a sublist is being formed;START: the element in the list to start the sublist at;LEN: the length of the sublist that is to be formed(defun SUB-LIST (L START LEN)	(cond		;if the length is zero, return nil		((equal LEN 0) nil) 		;if the list is nil, then return nil		((null L) nil)		;if the start of the sublist has been reached, then take		;the expression and add it to remainder of the sublist		((equal START 0) (cons (first L) (SUB-LIST (rest L) 0 (- LEN 1))))  		;else if it has not iterated to the first element in the sublist, step forward by one		(t (SUB-LIST (rest L) (- START 1) LEN)) ;	));;;SPLIT-LIST;;;;returns a list of two lists that each make up the first half and the second half of the passed list;L: the list to be split(defun SPLIT-LIST (L)	(cond 		;if the length of the list is even, divide the length evenly		;and get the sub list of both sides		((evenp (length L)) 			(list				(SUB-LIST L 0 (/ (length L) 2))				(SUB-LIST L (/ (length L) 2) (length L))			)		)		;if the length of the list is odd, get the length and separate		;so that the right list is larger than the left		(t 			(list				(SUB-LIST L 0 (/ (- (length L) 1) 2))				(SUB-LIST L (/ (- (length L) 1) 2) (length L))			)		)	));;;LIST2BTREE;;;;Returns a list with all of the elements organized in a binary tree structure;L: the list of items to be formed into a tree(defun LIST2BTREE (L)	(cond		;if the list is empty, return nil		((null L) nil)		;if the list has only one expression, return it		((equal (length L) 1) (first L))		;if the list contains two elements, return the list of the two elements		((equal (length L) 2) L)		;otherwise, turn both halves of the remaining list into trees and insert them as nodes		(t (list (LIST2BTREE (first (SPLIT-LIST L))) (LIST2BTREE  (first (rest (SPLIT-LIST L))))))	))